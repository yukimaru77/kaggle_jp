{
    "main_topic": {
        "author": "c-number",
        "title": "List of questions seen on the LB that can be answered with a rule-based algorithm.",
        "content": "# (Thoughts)\n\nWhile the secret collusion of a rule-based question/answer protocol goes against the goal of the competition, after reviewing some of the replays of top agents, it seems to me that it is only a matter of time before they (spontaneously, no offense intended) come to dominate the LB.\n\nAs pointed out by [@lohmaa](https://www.kaggle.com/lohmaa) [here](https://www.kaggle.com/competitions/llm-20-questions/discussion/511343#2866948), it would be unfair if only some of the players were aware of the protocol, as this would enhance their winning rate when they pair up together.\n\nTherefore, I have decided to list some of the protocol-like questions that have been observed on the leaderboard, in order to make the situation more fair.\n\nOf course, I do not believe this situation is desirable, but I think this approach at least makes the situation more fair.\n\nPerhaps changing the rules to always require players to team up with a randomly assigned LLM (e.g. Llama 3, Llama 2, Gemma) would keep LLM in play? [ref](https://www.kaggle.com/competitions/llm-20-questions/discussion/511343#2866948)\n\n# What is this?\n\nObserving the replays of top agents, one notices that some agents utilize questions that can be answered using a rule-based algorithm.\n\nAs pointed out [here](https://www.kaggle.com/competitions/llm-20-questions/discussion/515751), some things keywords seem to be almost impossible to be answered by a LLM (at least within 20 questions, what questions could make a LLM guess \"Cypress knee\"?), making rule-based question more engaging.\n\n(Asking rule-based questions might not be the best choice when the list of keywords is unknown, but at least for the answerer, answering correctly to the question is always the optimal strategy.)\n\nHere, I will introduce some of the questions that have been observed on the leaderboard, and also demonstrate how to answer them.\n\n# Questions\n\nDoes the keyword (in lowercase) come before \"laser\" in alphabetical order?\" [ref](https://www.kaggle.com/competitions/llm-20-questions/leaderboard?dialog=episodes-episode-55219628)\nDoes the keyword begins with the letter \"m\"? [ref](https://www.kaggle.com/competitions/llm-20-questions/leaderboard?dialog=episodes-episode-55203947)\nDoes the keyword start with one of the letters 'Z', 'G' or 'V'? [ref](https://www.kaggle.com/competitions/llm-20-questions/leaderboard?dialog=episodes-episode-55196291)\nIs the keyword one of the following? GPS, Graphing Calculator, Garbage Truck, Golf Cart, Garbage Disposal, Gravity, Glove, Gas Mask, Garbage bag, Guard tower? [ref](https://www.kaggle.com/competitions/llm-20-questions/leaderboard?dialog=episodes-episode-55196291)\nConsidering every letter in the name of the keyword, does the name of the keyword include the letter 'N'? [ref](https://www.kaggle.com/competitions/llm-20-questions/leaderboard?dialog=episodes-episode-55209104)\n\n# How to answer\n\nThe function below returns True/False if the question can be answered correctly, and returns None if it cannot. So you can just insert it in your answering pipeline just before feeding the question to your LLM.\n\n```\nimport re\n\ndef func1(keyword, question):\n    keyword_pattern = r\"^[a-zA-Z\\s]+$\"\n    question_pattern = r'^Does the keyword \\(in lowercase\\) come before \"([a-zA-Z\\s]+)\" in alphabetical order\\?$'\n    if not re.match(keyword_pattern, keyword) or not re.match(\n        question_pattern, question\n    ):\n        return None\n    match = re.match(question_pattern, question)\n    compare_word = match.group(1)\n    return keyword.lower() < compare_word.lower()\n\ndef func2(keyword, question):\n    keyword_pattern = r\"^[a-zA-Z\\s]+$\"\n    question_pattern = r'^Does the keyword begins with the letter \"([a-zA-Z])\"\\?$'\n\n    if not re.match(keyword_pattern, keyword) or not re.match(\n        question_pattern, question\n    ):\n        return None\n\n    match = re.match(question_pattern, question)\n    search_letter = match.group(1)\n\n    return keyword.strip().lower().startswith(search_letter.lower())\n\ndef func3(keyword, question):\n    keyword_pattern = r\"^[a-zA-Z\\s]+$\"\n    question_patterns = [\n        r\"^Does the keyword start with one of the letters \\'([a-zA-Z]\\'(?:, \\'[a-zA-Z]\\')*)(?: or \\'[a-zA-Z]\\')?\\?$\",\n        r\"^Does the keyword start with the letter \\'([a-zA-Z])\\'\\?$\",\n    ]\n    if not re.match(keyword_pattern, keyword) or not any(\n        re.match(pattern, question) for pattern in question_patterns\n    ):\n        return None\n    if re.match(question_patterns[0], question):\n        letters = re.findall(r\"'([a-zA-Z])'\", question)\n    else:\n        match = re.match(question_patterns[1], question)\n        letters = [match.group(1)]\n    letters = [c.lower() for c in letters]\n    return keyword.strip()[0].lower() in letters\n\ndef func4(keyword, question):\n    keyword_pattern = r\"^[a-zA-Z\\s]+$\"\n    question_pattern = r\"^Is the keyword one of the following\\? ([a-zA-Z\\s,]+)\\?$\"\n    if not re.match(keyword_pattern, keyword) or not re.match(\n        question_pattern, question\n    ):\n        return None\n    match = re.match(question_pattern, question)\n    options = [option.strip() for option in match.group(1).split(\",\")]\n    return keyword.strip().lower() in [option.lower() for option in options]\n\ndef func5(keyword, question):\n    keyword_pattern = r\"^[a-zA-Z\\s]+$\"\n    question_pattern = r\"^Considering every letter in the name of the keyword, does the name of the keyword include the letter \\'([A-Za-z])\\'\\?$\"\n    if not re.match(keyword_pattern, keyword) or not re.match(\n        question_pattern, question\n    ):\n        return None\n    match = re.match(question_pattern, question)\n    search_letter = match.group(1)\n    return search_letter.lower() in keyword.lower()\n\ndef func(keyword, question):\n    solves = [func1, func2, func3, func4, func5]\n    for f in solves:\n        result = f(keyword, question)\n        if result is not None:\n            return result\n    return None\n\n```\n\nHappy Kaggling\n\n",
        "date": "Sun Jun 30 2024 14:01:40 GMT+0900 (日本標準時)",
        "votes": "5"
    },
    "comments": [
        {
            "author": "loh-maa",
            "content": "Yes, I think you got it right. However, technically it's not the best way to handle the \"alpha\" protocol. The syntax doesn't matter much if only the testword is in double quotes and the answerer confirmed the 1st question. I don't know much about other protocols, but I think those regexes look very strict. Also, I think they also rely on the 1st question, asking something like \"Are we playing 20 questions?\"\n\n",
            "date": "Posted a month ago  ·  2nd in this Competition",
            "votes": "0",
            "reply": []
        }
    ]
}