# 3ビットのチート
**alekh** *2024年5月24日(金) 08:17:25 GMT+0900 (日本標準時)* (0票)
何か思いついたことがあります。回答者はケースを気にせずに回答できるため、回答者は「はい」または「いいえ」の情報に加えて、最大3ビットの情報を送信することで「チート」する機会があるかもしれません。
もしかしたら、これを利用するためのスキームが見つかるかもしれません。
---
# 他のユーザーからのコメント
> ## Bovard Doerschuk-Tiberi
> 
> たとえどんなケースで「はい」や「いいえ」を送信しても、リプレイ内では常に小文字に変換されます。
> 
> > ## alekhトピック作成者
> > 
> > つまり、そのハックは事実上無効化されているということですね。良いことだと思います。しかし、実現可能であれば面白い探求の道となったかもしれません。
> > 
> > 
---
> ## hengck23
> 
> 「それはBの文字で始まるの？」のような質問をしてもいいのか気になります。
> 
> 「その言葉には10文字以上ありますか？」
> 
> 「もしそれが…なら、「はい」と答えて、もしそれが…ならゆっくり「はい」と答えて…」
> 
> サーバーで「チーター」をチェックする必要があります。
> 
> 
---
> ## Nicholas Broad
> 
> あなたの言っていることを説明してもらえますか？ルールには、回答者が「はい」や「いいえ」以外の何かを回答した場合、自動的に試合に負けると書いてあります。
> 
> > ## alekhトピック作成者
> > 
> > 「はい」や「いいえ」をどんなケースで答えても問題ありません。つまり、はいの文字のケースを使って情報をエンコードすることができます。たとえば、yes、Yes、yEs、yeS、YEs、YeS、yES、YESなど。
> > 
> > 何らかのエンコーディングスキームを作成できて、たとえばキーワードの最初の文字がアルファベットの前半か後半かを示すことができたりします。それによって可能性を絞り込むことができます。
> > 
> > 
> > > ## alekhトピック作成者
> > > 
> > > 私がケースについて間違っている可能性があるので、そうなるとそれは機能しません。しかし、私はリプレイで「はい」と「Yes」の両方の回答を見たことがあると思いました。
> > > 
> > > 
> > > > ## Nicholas Broad
> > > > 
> > > それが機能するとは思えませんが、確証はありません。
> > > 
> > > 
---
> ## Chris Deotte
> 
> 時間を使って情報をエンコードすることができます。私たちのLLMは最初の10秒で回答を決定します。その後、10秒、20秒、30秒、40秒の時点で応答します。これにより、推測者に2ビットの情報をエンコードして渡すことが可能になります。
> 
> たとえば、単語の最初の文字がA-Fの間なら10秒で応答し、G-Lの間なら20秒、M-Rの間なら30秒、S-Zの間なら40秒で応答します。（もちろん、私たちの応答は尋ねられた質問に対する「はい」または「いいえ」です）。
> 
> このアプローチには問題があります。質問者と回答者の両方がこのシステムに従う必要がある点です。これは、Kaggleが一人のKagglerが質問者と回答者の両方を担当するのではなく、2チームの形式を採用した理由かもしれません。
> 
> 
---
> ## Kris Smith
> 
> これは機能しないと思います。ホストがこのことを考慮しているからです。
> 
> 回答者の出力はすべて小文字に処理されます。
> 
> ゲームのログを確認すると、彼らはリプレイされる前の生のLLMの応答を示しています。これが、異なるケースを見ている理由です。
> 
> コンペティション用のコードベースを読むと、ここで小文字に変換されているのがわかります：
> [https://github.com/Kaggle/kaggle-environments/blob/88d915db0a5db35536447a0ba2e2ca0845ef4e25/kaggle_environments/envs/llm_20_questions/llm_20_questions.py#L120](https://github.com/Kaggle/kaggle-environments/blob/88d915db0a5db35536447a0ba2e2ca0845ef4e25/kaggle_environments/envs/llm_20_questions/llm_20_questions.py#L120)
